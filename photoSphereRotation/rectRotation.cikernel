kernel vec4 rectRotation(sampler src, float x,float y, float z,float angle)
{
vec2 dest;
float theta,phi,r;
vec3 psph,tsph;

float pi= 3.141592654;
float width = samplerSize(src).x;
float height = samplerSize(src).y;
// Polar angles
theta = 2.0 * pi * (destCoord().x / width); // -pi to pi
phi = pi * (destCoord().y / height);  // -pi/2 to pi/2

// Vector in 3D space
if (theta<pi/2.0)
{
psph.x = sin(phi) * cos(theta);
psph.y = sin(phi) * sin(theta);
}
else if (theta<pi)
{
psph.x = -1.0* sin(phi) * cos(pi-theta);
psph.y =sin(phi) * sin(pi-theta);
}
else if (theta<pi*3.0/2.0)
{
psph.x =-1.0* sin(phi) * cos(theta-pi);
psph.y =-1.0* sin(phi) * sin(theta-pi);
}
else
{
psph.x =sin(phi) * cos(2.0*pi-theta);
psph.y =-1.0*sin(phi) * sin(2.0*pi-theta);
}

psph.z = cos(phi);

//transform matrix multiply
vec3 axis; axis.x=x; axis.y=y; axis.z=z;
float s = sin(angle);
float c = cos(angle);
float oc = 1.0 - c;

vec3 firstRow,secondRow,thirdRow;
firstRow.x=oc*axis.x*axis.x+c;
firstRow.y=oc*axis.x*axis.y-axis.z*s;
firstRow.z=oc*axis.z*axis.x+axis.y*s;

secondRow.x=oc*axis.x*axis.y+axis.z*s;
secondRow.y=oc*axis.y*axis.y+c;
secondRow.z=oc*axis.y*axis.z-axis.x*s;

thirdRow.x=oc*axis.z*axis.x-axis.y*s;
thirdRow.y=oc*axis.y*axis.z+axis.x*s;
thirdRow.z=oc*axis.z*axis.z+c;

tsph.x=psph.x*firstRow.x+psph.y*firstRow.y+psph.z*firstRow.z;
tsph.y=psph.x*secondRow.x+psph.y*secondRow.y+psph.z*secondRow.z;
tsph.z=psph.x*thirdRow.x+psph.y*thirdRow.y+psph.z*thirdRow.z;

//tsph=psph;
// change back to rect cord
phi=acos(tsph.z);

if (tsph.x>=0.0 && tsph.y>=0.0)
theta=atan(abs(tsph.y/tsph.x));
else if (tsph.x<=0.0 && tsph.y>=0.0 )
theta=pi-atan(abs(tsph.y/tsph.x));
else if (tsph.x<=0.0 && tsph.y<=0.0)
theta=pi+atan(abs(tsph.y/tsph.x));
else if (tsph.x>=0.0 && tsph.y<=0.0)
theta=pi*2.0-atan(abs(tsph.y/tsph.x));

dest.x=((theta)/(2.0*pi))*width;

dest.y=(phi/pi)*height;
//dest.x=destCoord().x;
//dest.y=destCoord().y;
return sample(src, samplerTransform(src, dest));
}


